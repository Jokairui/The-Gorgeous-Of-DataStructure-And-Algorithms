### Cue

什么是二叉查找树？

它的操作过程是怎么样的？

它的时间复杂度怎么样？

与散列表相比，它有哪些优势？

### Notes

#### 二叉查找树（Binary Search Tree）

树中任意一个结点，左子树的所有值都比该节点小，右子树的值都别该节点大

* 查找：类似二分查找，从根节点开始
* 插入：通过查找操作，找到对应的位置并插入
* 删除：根据被删除节点的位置，分三种情况。当然，一种简单的方法是直接不删除节点，将节点标记为被删除即可
  1. 叶子节点：直接删除
  2. 有一个子节点：用子节点代替当前节点
  3. 有两个子节点：找出当前节点的右子树的最小节点，用它替换当前节点，达到删除效果

#### 如何处理重复数据

1. 将节点拉出一个链表或指向其它类似数组的可以动态扩容的数据结构，达到一个节点存放多个相同数据的效果
2. 将相同节点放入右子树，即右子树存放的是大于等于当前节点的数据。这种情况下，查找操作在查找到第一个符合的数据时，不能停止，需要一直遍历到叶子节点为止。同样的删除操作时，也要遍历到叶子节点为止

#### 二叉查找树的时间复杂度

两个极端情况：

1. 二叉查找树退化成链表：显然查询、插入、删除都变成O(n)
2. 完全二叉树：O(lgn)，n表示节点的数量，因为平衡二叉树的时间复杂度为O(height),而完全二叉树的高度小于等于log2n.

#### 散列表于二叉查找树的对比

1. 散列表无序
2. 散列表扩容和散列冲突导致性能相当并不稳定
3. 笼统的说，因为哈希冲突的存在，以及散列函数的运算耗时，散列表的查询不一定就不二叉查找树快
4. 散列表的设计要考虑的东西比较多，包括散列函数，冲突解决，扩容等等，而二叉查找树就只需要考虑维护平衡性即可，设计上更简单
5. 由于扩容因子的存在，散列表的空间消耗通常更大些

### Summary

学习了一种特殊的二叉树，二叉查找树。它支持快速的查找、添加和删除。分析了它的复杂的，同时将它与散列表作了对比，提出了一些它的优势。