### Cue

四种复杂度分析

需要注意的两个点。事件概率、均摊场景

### Notes

函数用例: 返回一个数组总是否存在整数 x

``` // n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

1. 最好、最坏情况复杂度，分别为O(1) 和 O (n)

2. 平均时间复杂度，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。是表示为1 + 2 + …… + n + n / n + 1 = n(n+3) / 2(n+1)，时间复杂度为O(n)。

   而实际上n出现在数组中的概率是不同的，假设出现和不出现的概率各为1/2,那么就要求加权平均值。

   **实际情况中，如果最好、最坏、平均时间复杂度之间不存在量级差别，是不需要做区分的**

#### 均摊时间复杂度

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上

简单总结： 将复杂度高的那次操作的消耗均摊到其他多次复杂度低的操作上去，相当于很多人替一个人背锅

### Summary

分析了4种不同的时间复杂度，要注意的两个点：一个是平均复杂度要考虑事件概率，另一个是均摊复杂的的适用场景。

