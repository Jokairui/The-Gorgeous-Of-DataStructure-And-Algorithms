## Cue

优先队列

top k 问题

动态数据的中位数

## Notes

1. 优先级队列

   优先级队列有两个例子

   * 合并有序小文件。假设有100个文件，文件内数据已经按照从小到大顺序排列，可以从100个文件中依次取一条数据，放到优先级队列中，将最小的那一条放到一个新文件中，然后在从最小数据所在的文件中再读取一条数据与堆顶元素比较，如果比堆顶小，直接放到新文件中。否则，将堆顶元素放到新文件中，然后从堆顶元素所在的文件读取下一条数据。直到所有文件被合并完全为止。
   * 高性能定时器。假设有多个定时任务，常见的做法是程序每秒扫描一次定时任务列表，这样会有很多空跑，浪费性能，可以将所有任务放进一个优先队列中，程序只需要将当前时间与第一个要执行的任务时间相减，在这个间隔之后执行第一个定时任务即可，然后再移除第一个任务，同理再算出第二个任务的时间间隔。这样，就没有每秒的空跑来浪费性能了。

2. 求top k、bottom k类问题

   对于静态数据，可以维护一个k大小的**小顶堆**，顺序遍历数组，如果当前元素比堆顶元素大，就移除堆顶元素，并将当前元素则放入堆中。遍历完数组后，整个堆内元素就是top k元素了

   对于动态数据，可以一直维护一个k大小的小顶堆，每一次增加数据，都与堆顶元素做一次比较。

3. 求**动态数据集合中**的中位数

   将原始的数据排序后分成两份，小的n/2组成一个大顶堆，大的n/2组成一个小顶堆，如果n为奇数，那么大顶堆多存一个数。此时，如果n为奇数，中位数为大顶堆的堆顶元素；n为偶数，中位数为两个堆顶元素的平均值，或者也可以任取一个做中位数

   同理，也可以求所谓的“99%响应时间”。即数据中处于第99%位置的数。

   对于动态数据来说，如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。

   如果因为插入导致大小顶堆的数量不能满足原来的条件，可以通过将堆顶元素移动到另一个堆的方式进行平衡

## Summary

了解了3个堆的使用场景，包括优先级队列，top k问题，以及求动态数据的中位数。

